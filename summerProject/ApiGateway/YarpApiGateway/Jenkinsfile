pipeline {
  agent any
  environment {
    DOTNET_CLI_TELEMETRY_OPTOUT = '1'

    // === SERVICE-SPECIFIC ===
    CSPROJ       = 'summerProject/ApiGateway/YarpApiGateway/YarpApiGateway.csproj'
    PROJECT_DIR  = 'summerProject/ApiGateway/YarpApiGateway'
    IMAGE_REPO   = 'duythong2/yarpgateway'
    IMAGE_TAG    = "${env.BUILD_NUMBER}"

    SONAR_PROJECT_KEY = 'yarpGateway'

    // Jenkins credentials
    DOCKERHUB   = credentials('dockerhub-creds')
    SONAR_TOKEN = credentials('sonartoken')

    // Toggles
    ENABLE_SONAR_BRANCH = '0'            // set '1' if SonarQube supports Branch Analysis (Developer+)
    DOCKER_LOCK_RESOURCE = 'docker-daemon' // requires Lockable Resources plugin; set '' if not available
  }
  options { timestamps(); disableConcurrentBuilds() }

  stages {
    stage('Checkout') { steps { checkout scm } }

    stage('Detect relevant changes') {
      steps {
        script {
          def isFirst = (sh(returnStatus: true, script: 'git rev-parse HEAD~1 >/dev/null 2>&1') != 0)
          def diff = sh(returnStdout: true, script: '''
            set -e
            git fetch --no-tags origin || true
            if [ -n "$CHANGE_TARGET" ]; then
              git diff --name-only "origin/$CHANGE_TARGET"...HEAD
            else
              if git rev-parse HEAD~1 >/dev/null 2>&1; then
                git diff --name-only HEAD~1..HEAD
              else
                echo ""
              fi
            fi
          ''').trim().split("\\r?\\n").findAll { it?.trim() }

          // ApiGateway + Shared
          def pattern = ~/^(summerProject\/ApiGateway\/|summerProject\/Shared\/).*/
          def relevant = isFirst || diff.any { it ==~ pattern }

          // Write a workspace marker for later stages
          writeFile file: '.run_pipeline', text: (relevant ? '1' : '0')

          if (relevant) {
            def touched = diff.findAll { it ==~ pattern }
            echo "Relevant changes detected (or first build). Running heavy stages."
            if (touched) { echo "Touched files:\n" + touched.join('\n') }
          } else {
            echo "No relevant changes for ApiGateway/Shared. Heavy stages will be skipped (build stays GREEN)."
          }
        }
      }
    }

    stage('Tools (local dotnet tools)') {
      when { expression { fileExists('.run_pipeline') && readFile('.run_pipeline').trim() == '1' } }
      steps {
        sh '''
          set -e
          if [ ! -f .config/dotnet-tools.json ]; then
            echo "[tools] Create local tool manifest & install scanner..."
            dotnet new tool-manifest
            dotnet tool install dotnet-sonarscanner --version 10.3.0
          else
            echo "[tools] Restore local tools..."
            dotnet tool restore
            req_ver=10.3.0
            cur_ver=$(dotnet tool list | awk '/dotnet-sonarscanner/ {print $2}')
            if [ "$cur_ver" != "$req_ver" ]; then
              echo "[tools] Update dotnet-sonarscanner to $req_ver..."
              dotnet tool update dotnet-sonarscanner --version "$req_ver"
            fi
          fi
          dotnet tool run dotnet-sonarscanner -- --version
        '''
      }
    }

    stage('Start Analysis') {
      when { expression { fileExists('.run_pipeline') && readFile('.run_pipeline').trim() == '1' } }
      steps {
        withSonarQubeEnv('sonarServer') {
          script {
            // Build command as a list to avoid quoting issues
            def args = [
              'dotnet tool run dotnet-sonarscanner begin',
              "/k:${env.SONAR_PROJECT_KEY}",
              "/d:sonar.login=${env.SONAR_TOKEN}",
              "/d:sonar.host.url=${env.SONAR_HOST_URL}"
            ]
            if ((env.ENABLE_SONAR_BRANCH ?: '0') == '1' && env.BRANCH_NAME && !(env.BRANCH_NAME in ['main','master'])) {
              args << "/d:sonar.branch.name=${env.BRANCH_NAME}"
            }
            sh args.join(' ')
          }
        }
      }
    }

    stage('Restore & Test') {
      when { expression { fileExists('.run_pipeline') && readFile('.run_pipeline').trim() == '1' } }
      steps {
        sh '''
          dotnet restore "$CSPROJ"
          dotnet test "$CSPROJ" -c Release --logger "trx;LogFileName=test.trx"
        '''
      }
    }

    stage('Build & Publish') {
      when { expression { fileExists('.run_pipeline') && readFile('.run_pipeline').trim() == '1' } }
      steps {
        sh 'dotnet publish "$CSPROJ" -c Release -o "$PROJECT_DIR/publish"'
      }
    }

    stage('Finish Analysis') {
      when { expression { fileExists('.run_pipeline') && readFile('.run_pipeline').trim() == '1' } }
      steps {
        withSonarQubeEnv('sonarServer') {
          sh 'dotnet tool run dotnet-sonarscanner end /d:sonar.login="$SONAR_TOKEN"'
        }
      }
    }

    stage('Quality Gate') {
      when { expression { fileExists('.run_pipeline') && readFile('.run_pipeline').trim() == '1' } }
      steps {
        timeout(time: 10, unit: 'MINUTES') {
          script {
            def qg = waitForQualityGate()
            if (qg.status != 'OK') { error "Quality Gate failed: ${qg.status}" }
          }
        }
      }
    }

    stage('Docker Build & Push') {
      when { expression { fileExists('.run_pipeline') && readFile('.run_pipeline').trim() == '1' } }
      steps {
        script {
          def dockerSteps = {
            sh '''
              export DOCKER_BUILDKIT=1
              echo "$DOCKERHUB_PSW" | docker login -u "$DOCKERHUB_USR" --password-stdin

              docker build -t "$IMAGE_REPO:$IMAGE_TAG" \
                -f "$PROJECT_DIR/Dockerfile" \
                summerProject

              docker push "$IMAGE_REPO:$IMAGE_TAG"

              if [ "$BRANCH_NAME" = "main" ] || [ "$BRANCH_NAME" = "master" ]; then
                docker tag  "$IMAGE_REPO:$IMAGE_TAG" "$IMAGE_REPO:latest"
                docker push "$IMAGE_REPO:latest"
              else
                echo "Skip pushing 'latest' on branch $BRANCH_NAME"
              fi
            '''
          }
          if (env.DOCKER_LOCK_RESOURCE?.trim()) {
            lock(resource: env.DOCKER_LOCK_RESOURCE) { dockerSteps() }
          } else {
            dockerSteps()
          }
        }
      }
    }
  }

  post {
    always { junit allowEmptyResults: true, testResults: '**/TestResults/**/*.trx' }
  }
}
