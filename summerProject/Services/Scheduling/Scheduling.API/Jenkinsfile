pipeline {
  agent any
  environment {
    DOTNET_CLI_TELEMETRY_OPTOUT = '1'
    CSPROJ      = 'summerProject/Services/Scheduling/Scheduling.API/Scheduling.API.csproj'
    PROJECT_DIR = 'summerProject/Services/Scheduling/Scheduling.API'

    DOCKERHUB   = credentials('dockerhub-creds')
    IMAGE_REPO  = 'duythong2/scheduling-api'
    IMAGE_TAG   = "${env.BUILD_NUMBER}"

    SONAR_TOKEN       = credentials('sonartoken')
    SONAR_PROJECT_KEY = 'scheduling-api'

    // Optional toggles
    ENABLE_SONAR_BRANCH   = '0'              // set '1' if SonarQube supports Branch Analysis (Developer+)
    DOCKER_LOCK_RESOURCE  = 'docker-daemon'  // requires Lockable Resources plugin; set '' if not available
  }
  options { timestamps(); disableConcurrentBuilds() }

  stages {
    stage('Checkout') { steps { checkout scm } }

    stage('Detect relevant changes') {
      steps {
        script {
          def isFirst = (sh(returnStatus: true, script: 'git rev-parse HEAD~1 >/dev/null 2>&1') != 0)
          def diff = sh(returnStdout: true, script: '''
            set -e
            git fetch --no-tags origin || true
            if [ -n "$CHANGE_TARGET" ]; then
              git diff --name-only "origin/$CHANGE_TARGET"...HEAD
            else
              if git rev-parse HEAD~1 >/dev/null 2>&1; then
                git diff --name-only HEAD~1..HEAD
              else
                echo ""
              fi
            fi
          ''').trim().split("\\r?\\n").findAll { it?.trim() }

          // Scheduling service + BuildingBlocks
          def pattern  = ~/^(summerProject\/Services\/Scheduling\/|summerProject\/BuildingBlocks\/).*/
          def relevant = isFirst || diff.any { it ==~ pattern }

          // Write a workspace marker for later stages
          writeFile file: '.run_pipeline', text: (relevant ? '1' : '0')

          if (relevant) {
            def touched = diff.findAll { it ==~ pattern }
            echo "Relevant changes detected (or first build). Running heavy stages."
            if (touched) { echo "Touched files:\n" + touched.join('\n') }
          } else {
            echo "No relevant changes for Scheduling/BuildingBlocks. Heavy stages will be skipped (build stays GREEN)."
          }
        }
      }
    }

    stage('Start Analysis') {
      when { expression { fileExists('.run_pipeline') && readFile('.run_pipeline').trim() == '1' } }
      steps {
        withSonarQubeEnv('sonarServer') {
          // prepare local tools first (avoid global tool race)
          sh '''
            set -e
            if [ ! -f .config/dotnet-tools.json ]; then
              dotnet new tool-manifest
              dotnet tool install dotnet-sonarscanner --version 10.3.0
            else
              dotnet tool restore
            fi
          '''
          // run begin with safe argument building
          script {
            def args = [
              'dotnet tool run dotnet-sonarscanner begin',
              "/k:${env.SONAR_PROJECT_KEY}",
              "/d:sonar.login=${env.SONAR_TOKEN}",
              "/d:sonar.host.url=${env.SONAR_HOST_URL}"
            ]
            if ((env.ENABLE_SONAR_BRANCH ?: '0') == '1' &&
                env.BRANCH_NAME && !(env.BRANCH_NAME in ['main','master'])) {
              args << "/d:sonar.branch.name=${env.BRANCH_NAME}"
            }
            sh args.join(' ')
          }
        }
      }
    }

    stage('Restore & Test') {
      when { expression { fileExists('.run_pipeline') && readFile('.run_pipeline').trim() == '1' } }
      steps {
        sh '''
          dotnet restore "$CSPROJ"
          dotnet test "$CSPROJ" -c Release --logger "trx;LogFileName=test.trx"
        '''
      }
    }

    stage('Build & Publish') {
      when { expression { fileExists('.run_pipeline') && readFile('.run_pipeline').trim() == '1' } }
      steps {
        sh 'dotnet publish "$CSPROJ" -c Release -o "$PROJECT_DIR/publish"'
      }
    }

    stage('Finish Analysis') {
      when { expression { fileExists('.run_pipeline') && readFile('.run_pipeline').trim() == '1' } }
      steps {
        withSonarQubeEnv('sonarServer') {
          sh 'dotnet tool run dotnet-sonarscanner end /d:sonar.login="$SONAR_TOKEN"'
        }
      }
    }

    stage('Quality Gate') {
      when { expression { fileExists('.run_pipeline') && readFile('.run_pipeline').trim() == '1' } }
      steps {
        timeout(time: 10, unit: 'MINUTES') {
          script {
            def qg = waitForQualityGate()
            if (qg.status != 'OK') { error "Quality Gate failed: ${qg.status}" }
          }
        }
      }
    }

    stage('Docker Build & Push') {
      when { expression { fileExists('.run_pipeline') && readFile('.run_pipeline').trim() == '1' } }
      steps {
        script {
          def dockerSteps = {
            sh '''
              export DOCKER_BUILDKIT=1
              echo "$DOCKERHUB_PSW" | docker login -u "$DOCKERHUB_USR" --password-stdin

              docker build -t "$IMAGE_REPO:$IMAGE_TAG" \
                -f "$PROJECT_DIR/Dockerfile" \
                summerProject

              docker push "$IMAGE_REPO:$IMAGE_TAG"

              # push 'latest' only on main/master
              if [ "$BRANCH_NAME" = "main" ] || [ "$BRANCH_NAME" = "master" ]; then
                docker tag  "$IMAGE_REPO:$IMAGE_TAG" "$IMAGE_REPO:latest"
                docker push "$IMAGE_REPO:latest"
              else
                echo "Skip pushing 'latest' on branch $BRANCH_NAME"
              fi
            '''
          }
          if (env.DOCKER_LOCK_RESOURCE?.trim()) {
            lock(resource: env.DOCKER_LOCK_RESOURCE) { dockerSteps() }
          } else {
            dockerSteps()
          }
        }
      }
    }
  }

  post {
    always {
      sh 'rm -f .run_pipeline || true'
      junit allowEmptyResults: true, testResults: '**/TestResults/**/*.trx'
    }
  }
}
